/* =========================================================================
   ASCENSOR UNIPERSONAL 3 PISOS - ESP32
   Versi√≥n integrada con WiFi, Firebase Realtime Database y Telegram
   - Mantiene toda la l√≥gica original del ascensor sin modificaciones
   - A√±ade conectividad WiFi y env√≠o de mensajes a Firebase
   - Notificaciones cr√≠ticas a Telegram (inicio y emergencias)
   ========================================================================= */

#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiClientSecure.h>

/* =============================
   CONFIGURACI√ìN WiFi y SERVICIOS
   ============================= */
const char* ssid = "Wokwi-GUEST";
const char* password = "";

// Firebase
const char* firebaseHost = "https://monitor-ascensor-default-rtdb.firebaseio.com/messages.json";
String FIREBASE_SECRET = "AqLC2Op9BaxNHpQsj25vGfN9mx8744HK73K8mF9A";

// Telegram
String BOT_TOKEN = "8440872935:AAFbZXaGm5Lb2SzvOyNVvK-OUfbVDkSSFAE";
String CHAT_ID = "1524235695";

WiFiClientSecure client;
HTTPClient http;

/* =============================
   CONFIGURACI√ìN DE PINES (AJUSTAR SI ES NECESARIO)
   ============================= */

// Botones de llamada externos (un bot√≥n por piso)
#define BTN_CALL_P1  33
#define BTN_CALL_P2  32
#define BTN_CALL_P3  25

// Botones internos de cabina (un bot√≥n por piso)
#define BTN_IN_P1    26
#define BTN_IN_P2    27
#define BTN_IN_P3    14

// Sensores de posici√≥n (finales de piso)
#define FC_P1  4
#define FC_P2  5
#define FC_P3  18

// Finales de carrera (l√≠mites cr√≠tico superior / inferior)
#define FC_LIM_SUP 19
#define FC_LIM_INF 21

// Sensores de puertas: un sensor por piso (HIGH = puerta CERRADA)
#define DOOR_P1 22
#define DOOR_P2 23
#define DOOR_P3 35

// Bot√≥n de emergencia (HIGH = activado)
#define EMERGENCY 13

// Bot√≥n interno para abrir puerta manualmente (cabina)
#define BTN_OPEN_DOOR 34

// Rel√©s de movimiento (salidas) - HIGH activa la funci√≥n
#define RELAY_UP        2   // Subir
#define RELAY_DOWN     15   // Bajar

// Rel√©s de apertura el√©ctrica de cerraduras de puertas (salidas)
#define RELAY_DOOR_LOCK_1 12  // Cerradura piso 1 (o cerradura cabina)
#define RELAY_DOOR_LOCK_2 16  // Cerradura piso 2/3 (usar seg√∫n mec√°nica)

// =============================
// TIEMPOS (ms) - conforme a especificaci√≥n
// =============================
const unsigned long DOOR_UNLOCK_MS      = 10000UL; // 10 s de rel√© activado (libera cerradura)
const unsigned long DOOR_WAIT_MS        = 10000UL; // 10 s de puerta "abierta" esperando entrada
const unsigned long INACTIVITY_MS       = 10000UL; // 10 s sin llamadas -> retornar a piso 1
const unsigned long DEBOUNCE_MS         = 40UL;    // debounce simple
const unsigned long LOOP_DELAY_MS       = 10UL;    // ciclo principal sleep

// =============================
// M√ÅQUINA DE ESTADOS (11 estados exactos)
// =============================
enum Estado {
  ESTADO_AUTODIAGNOSTICO,
  ESTADO_BAJAR_A_PISO_1_INICIAL,
  ESTADO_ESPERA_PISOS,
  ESTADO_ATENDIENDO_LLAMADA_PRIMARIA,
  ESTADO_ATENDIENDO_LLAMADA_SECUNDARIA,
  ESTADO_MOVIMIENTO_SUBIENDO,
  ESTADO_MOVIMIENTO_BAJANDO,
  ESTADO_APERTURA_PUERTAS,
  ESTADO_VENTANA_INTERNA,
  ESTADO_RETORNO_PISO_1,
  ESTADO_EMERGENCIA
};

Estado estado = ESTADO_AUTODIAGNOSTICO;

// =============================
// VARIABLES GLOBALES
// =============================
int currentFloor = 1;         // estimaci√≥n del piso actual (1..3). Se confirmar√° por sensores.
int targetFloor  = 0;         // piso objetivo actual
int callQueue[2] = {0, 0};    // cola FIFO para llamadas externas (max 2)
unsigned long lastActivity = 0; // timestamp de √∫ltima actividad (para retorno por inactividad)
bool motorMoving = false;

/* =============================
   FUNCIONES DE CONECTIVIDAD
   ============================= */

void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;

  Serial.println("Conectando a WiFi...");
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(200);
    Serial.print(".");
  }
  Serial.println("\n‚úî WiFi conectado.");
}

String escapeJson(const String &s) {
  String o = "";
  for (char c : s) {
    if (c == '\"') o += "\\\"";
    else if (c == '\\') o += "\\\\";
    else if (c == '\n') o += "\\n";
    else if (c == '\r') o += "\\r";
    else if (c == '\t') o += "\\t";
    else o += c;
  }
  return o;
}

void enviarMensaje(const String &mensaje) {
  // Imprimir en Serial (comportamiento original)
  Serial.println(mensaje);

  // Enviar a Firebase si WiFi est√° conectado
  if (WiFi.status() != WL_CONNECTED) return;

  unsigned long ts = millis();
  String mensajeEscapado = escapeJson(mensaje);

  // Construir JSON
  String json = "{\"mensaje\":\"" + mensajeEscapado + "\",\"ts\":" + String(ts) + "}";

  // URL con autenticaci√≥n
  String url = String(firebaseHost) + "?auth=" + FIREBASE_SECRET;

  // Enviar a Firebase
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");

  int httpCode = http.POST(json);

  if (httpCode > 0) {
    // Mensaje enviado correctamente (opcional: descomentar para debug)
    // Serial.print("Firebase OK | Code: ");
    // Serial.println(httpCode);
  } else {
    Serial.print("Firebase ERROR: ");
    Serial.println(httpCode);
  }

  http.end();
  delay(10); // peque√±o respiro
}

void enviarTelegram(const String &mensaje) {
  if (WiFi.status() != WL_CONNECTED) return;

  String url = "https://api.telegram.org/bot" + BOT_TOKEN + "/sendMessage";
  String mensajeEscapado = escapeJson(mensaje);
  String payload = "{\"chat_id\":\"" + CHAT_ID + "\",\"text\":\"" + mensajeEscapado + "\"}";

  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");

  int httpCode = http.POST(payload);

  if (httpCode > 0) {
    Serial.println("Telegram enviado correctamente");
  } else {
    Serial.print("Telegram ERROR: ");
    Serial.println(httpCode);
  }

  http.end();
  delay(10);
}

// =============================
// UTILIDADES DE LECTURA (debounce simple)
// =============================
bool readHighStable(uint8_t pin) {
  if (digitalRead(pin) != HIGH) return false;
  unsigned long t0 = millis();
  while (millis() - t0 < DEBOUNCE_MS) if (digitalRead(pin) != HIGH) return false;
  return true;
}
bool readLowStable(uint8_t pin) {
  if (digitalRead(pin) != LOW) return false;
  unsigned long t0 = millis();
  while (millis() - t0 < DEBOUNCE_MS) if (digitalRead(pin) != LOW) return false;
  return true;
}

// =============================
// SENSORES / ESTADOS FISICOS
// =============================
bool anyDoorClosed() {
  return (digitalRead(DOOR_P1) == HIGH) &&
         (digitalRead(DOOR_P2) == HIGH) &&
         (digitalRead(DOOR_P3) == HIGH);
}

bool emergencySignal() {
  return (digitalRead(EMERGENCY) == HIGH) ||
         (digitalRead(FC_LIM_SUP) == HIGH) ||
         (digitalRead(FC_LIM_INF) == HIGH);
}

bool sensorAtFloor(int f) {
  if (f == 1) return (digitalRead(FC_P1) == HIGH);
  if (f == 2) return (digitalRead(FC_P2) == HIGH);
  if (f == 3) return (digitalRead(FC_P3) == HIGH);
  return false;
}

// =============================
// GESTI√ìN DE COLA DE LLAMADAS EXTERNAS (FIFO, max 2)
// =============================
void logCallQueue() {
  char buffer[50];
  snprintf(buffer, sizeof(buffer), "Cola extern: [%d, %d]", callQueue[0], callQueue[1]);
  enviarMensaje(buffer);
}

void addExternalCall(int floor) {
  if (floor < 1 || floor > 3) return;
  // evitar duplicados
  if (callQueue[0] == floor || callQueue[1] == floor) {
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "LLAMADA P%d ya registrada (sin duplicar)", floor);
    enviarMensaje(buffer);
    return;
  }
  if (callQueue[0] == 0) {
    callQueue[0] = floor;
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "Llamada externa agregada en slot1: P%d", floor);
    enviarMensaje(buffer);
    lastActivity = millis();
    logCallQueue();
    return;
  }
  if (callQueue[1] == 0) {
    callQueue[1] = floor;
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "Llamada externa agregada en slot2: P%d", floor);
    enviarMensaje(buffer);
    lastActivity = millis();
    logCallQueue();
    return;
  }
  enviarMensaje("LLAMADA INV√ÅLIDA");
}

int popExternalCall() {
  int next = callQueue[0];
  callQueue[0] = callQueue[1];
  callQueue[1] = 0;
  logCallQueue();
  return next;
}

// =============================
// CONTROL SEGURO DE MOTORES
// =============================
void stopMotion() {
  digitalWrite(RELAY_UP, LOW);
  digitalWrite(RELAY_DOWN, LOW);
  motorMoving = false;
  enviarMensaje("Motor PARADO (salidas SUBIR/BAJAR LOW)");
}

void activateUpSafe() {
  if (!anyDoorClosed()) {
    enviarMensaje("RECHAZO SUBIR: al menos una puerta abierta");
    return;
  }
  if (digitalRead(FC_LIM_SUP) == HIGH) {
    enviarMensaje("RECHAZO SUBIR: l√≠mite superior activo");
    return;
  }
  stopMotion();
  delay(5);
  digitalWrite(RELAY_UP, HIGH);
  motorMoving = true;
  enviarMensaje("Rel√© SUBIR = HIGH (activado)");
}

void activateDownSafe() {
  if (!anyDoorClosed()) {
    enviarMensaje("RECHAZO BAJAR: al menos una puerta abierta");
    return;
  }
  if (digitalRead(FC_LIM_INF) == HIGH) {
    enviarMensaje("RECHAZO BAJAR: l√≠mite inferior activo");
    return;
  }
  stopMotion();
  delay(5);
  digitalWrite(RELAY_DOWN, HIGH);
  motorMoving = true;
  enviarMensaje("Rel√© BAJAR = HIGH (activado)");
}

// =============================
// SECUENCIA DE APERTURA DE PUERTAS
// =============================
void performDoorSequence() {
  char buffer[80];
  snprintf(buffer, sizeof(buffer), "Apertura: Activando rel√©(s) de cerradura por %lu ms", DOOR_UNLOCK_MS);
  enviarMensaje(buffer);
  
  digitalWrite(RELAY_DOOR_LOCK_1, HIGH);
  digitalWrite(RELAY_DOOR_LOCK_2, HIGH);

  unsigned long t0 = millis();
  while (millis() - t0 < DOOR_UNLOCK_MS) {
    if (emergencySignal()) {
      enviarMensaje("EMERGENCIA durante activaci√≥n de cerradura -> abortando apertura");
      digitalWrite(RELAY_DOOR_LOCK_1, LOW);
      digitalWrite(RELAY_DOOR_LOCK_2, LOW);
      return;
    }
    if (readHighStable(BTN_CALL_P1)) addExternalCall(1);
    if (readHighStable(BTN_CALL_P2)) addExternalCall(2);
    if (readHighStable(BTN_CALL_P3)) addExternalCall(3);
    delay(5);
  }

  digitalWrite(RELAY_DOOR_LOCK_1, LOW);
  digitalWrite(RELAY_DOOR_LOCK_2, LOW);
  enviarMensaje("Rel√©s de cerradura DESACTIVADOS (la puerta permanecer√° abierta por bisagra)");

  snprintf(buffer, sizeof(buffer), "Puertas abiertas (esperando) por %lu ms", DOOR_WAIT_MS);
  enviarMensaje(buffer);
  
  t0 = millis();
  while (millis() - t0 < DOOR_WAIT_MS) {
    if (emergencySignal()) {
      enviarMensaje("EMERGENCIA durante puerta abierta -> entrando a EMERGENCIA");
      return;
    }
    if (readHighStable(BTN_CALL_P1)) addExternalCall(1);
    if (readHighStable(BTN_CALL_P2)) addExternalCall(2);
    if (readHighStable(BTN_CALL_P3)) addExternalCall(3);
    
    if (readHighStable(BTN_OPEN_DOOR) && !motorMoving && sensorAtFloor(currentFloor)) {
      enviarMensaje("Bot√≥n interno de apertura PRESIONADO durante ventana -> reactivando apertura 10s");
      unsigned long t1 = millis();
      digitalWrite(RELAY_DOOR_LOCK_1, HIGH);
      digitalWrite(RELAY_DOOR_LOCK_2, HIGH);
      while (millis() - t1 < DOOR_UNLOCK_MS) {
        if (emergencySignal()) {
          digitalWrite(RELAY_DOOR_LOCK_1, LOW);
          digitalWrite(RELAY_DOOR_LOCK_2, LOW);
          enviarMensaje("EMERGENCIA durante re-apertura -> abortando");
          return;
        }
        if (readHighStable(BTN_CALL_P1)) addExternalCall(1);
        if (readHighStable(BTN_CALL_P2)) addExternalCall(2);
        if (readHighStable(BTN_CALL_P3)) addExternalCall(3);
        delay(5);
      }
      digitalWrite(RELAY_DOOR_LOCK_1, LOW);
      digitalWrite(RELAY_DOOR_LOCK_2, LOW);
      enviarMensaje("Re-apertura finalizada");
    }
    delay(5);
  }
  enviarMensaje("Fin de ventana de puertas (DOOR_WAIT_MS)");
}

// =============================
// AUTODIAGNOSTICO
// =============================
bool testRelays() {
  enviarMensaje("Prueba rel√©s: SUBIR, BAJAR, DOOR_LOCKS (pulsos breves)");
  digitalWrite(RELAY_UP, HIGH); delay(80); digitalWrite(RELAY_UP, LOW);
  digitalWrite(RELAY_DOWN, HIGH); delay(80); digitalWrite(RELAY_DOWN, LOW);
  digitalWrite(RELAY_DOOR_LOCK_1, HIGH); delay(80); digitalWrite(RELAY_DOOR_LOCK_1, LOW);
  digitalWrite(RELAY_DOOR_LOCK_2, HIGH); delay(80); digitalWrite(RELAY_DOOR_LOCK_2, LOW);
  enviarMensaje("Prueba rel√©s completada (verificar f√≠sicamente si se requiere).");
  return true;
}

bool runAutodiagnostic() {
  enviarMensaje("=== INICIO AUTODIAGN√ìSTICO ===");
  enviarMensaje("Alimentaci√≥n detectada: OK");

  if (!testRelays()) {
    enviarMensaje("FALLO en testRelays");
    return false;
  }

  char buffer[80];
  snprintf(buffer, sizeof(buffer), "Sensor puertas: P1=%d P2=%d P3=%d", 
           digitalRead(DOOR_P1), digitalRead(DOOR_P2), digitalRead(DOOR_P3));
  enviarMensaje(buffer);

  if (digitalRead(FC_LIM_SUP) == HIGH || digitalRead(FC_LIM_INF) == HIGH) {
    enviarMensaje("ERROR: Final de carrera superior/ inferior activo durante autodiagn√≥stico");
    return false;
  }

  if (digitalRead(EMERGENCY) == HIGH) {
    enviarMensaje("ERROR: Bot√≥n EMERGENCIA activado durante autodiagn√≥stico");
    return false;
  }

  snprintf(buffer, sizeof(buffer), "Sensores piso: P1=%d P2=%d P3=%d", 
           digitalRead(FC_P1), digitalRead(FC_P2), digitalRead(FC_P3));
  enviarMensaje(buffer);

  enviarMensaje("=== AUTODIAGN√ìSTICO OK ===");
  return true;
}

// =============================
// ENTRADA Y LECTURAS CONSTANTES
// =============================
void registerExternalCallsIfAny() {
  if (estado == ESTADO_EMERGENCIA) return;
  if (readHighStable(BTN_CALL_P1)) addExternalCall(1);
  if (readHighStable(BTN_CALL_P2)) addExternalCall(2);
  if (readHighStable(BTN_CALL_P3)) addExternalCall(3);
}

int readInternalCall() {
  if (estado == ESTADO_EMERGENCIA) return 0;
  if (readHighStable(BTN_IN_P1)) return 1;
  if (readHighStable(BTN_IN_P2)) return 2;
  if (readHighStable(BTN_IN_P3)) return 3;
  return 0;
}

// =============================
// FUNCIONES DE ESTADO
// =============================
void enterEmergency(const char* reason) {
  estado = ESTADO_EMERGENCIA;
  stopMotion();
  String mensaje = "!!! ENTRANDO EN ESTADO_EMERGENCIA: ";
  mensaje += reason;
  enviarMensaje(mensaje);
  
  // Notificaci√≥n cr√≠tica a Telegram
  String telegramMsg = "üö® EMERGENCIA EN EL ASCENSOR üö®\n";
  telegramMsg += "Raz√≥n: ";
  telegramMsg += reason;
  enviarTelegram(telegramMsg);
}

void state_autodiagnostico() {
  enviarMensaje("[ESTADO_AUTODIAGNOSTICO]");
  if (!runAutodiagnostic()) {
    enterEmergency("Autodiagn√≥stico fall√≥");
    return;
  }
  estado = ESTADO_BAJAR_A_PISO_1_INICIAL;
}

void state_bajar_a_piso_1_inicial() {
  enviarMensaje("[ESTADO_BAJAR_A_PISO_1_INICIAL] Iniciando bajada a Piso 1");
  if (!anyDoorClosed()) {
    enterEmergency("Puertas no cerradas al iniciar bajada inicial");
    return;
  }
  if (digitalRead(FC_LIM_INF) == HIGH) {
    enterEmergency("Final carrera inferior activo al iniciar bajada inicial");
    return;
  }
  activateDownSafe();
  while (!sensorAtFloor(1)) {
    registerExternalCallsIfAny();
    if (emergencySignal()) {
      stopMotion();
      enterEmergency("Emergencia detectada durante bajada inicial");
      return;
    }
    delay(5);
  }
  stopMotion();
  currentFloor = 1;
  enviarMensaje("Llegado a Piso 1 (inicio). Transicion a ESPERA_PISOS");
  lastActivity = millis();
  estado = ESTADO_ESPERA_PISOS;
}

void state_espera_pisos() {
  registerExternalCallsIfAny();

  if (emergencySignal()) { enterEmergency("Emergencia detectada en ESPERA"); return; }

  int internal = readInternalCall();
  if (internal > 0) {
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "Orden INTERNA detectada en ESPERA: P%d", internal);
    enviarMensaje(buffer);
    targetFloor = internal;
    estado = ESTADO_ATENDIENDO_LLAMADA_PRIMARIA;
    return;
  }

  if (callQueue[0] > 0) {
    targetFloor = popExternalCall();
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "Atendiendo llamada PRIMARIA externa: ir a P%d", targetFloor);
    enviarMensaje(buffer);
    estado = ESTADO_ATENDIENDO_LLAMADA_PRIMARIA;
    return;
  }

  if (millis() - lastActivity > INACTIVITY_MS) {
    if (currentFloor != 1) {
      enviarMensaje("Inactividad detectada -> RETORNO_PISO_1");
      estado = ESTADO_RETORNO_PISO_1;
      return;
    } else {
      lastActivity = millis();
    }
  }

  if (readHighStable(BTN_OPEN_DOOR) && sensorAtFloor(currentFloor) && !motorMoving) {
    enviarMensaje("Bot√≥n interno abrir puerta PRESIONADO en ESPERA -> iniciando apertura");
    estado = ESTADO_APERTURA_PUERTAS;
    return;
  }
}

void state_atendiendo_llamada_primaria() {
  char buffer[60];
  snprintf(buffer, sizeof(buffer), "[ESTADO_ATENDIENDO_LLAMADA_PRIMARIA] Target = P%d", targetFloor);
  enviarMensaje(buffer);
  
  registerExternalCallsIfAny();
  if (!anyDoorClosed()) { enterEmergency("Puertas abiertas al intentar atender primaria"); return; }
  if (emergencySignal()) { enterEmergency("Emergencia al intentar atender primaria"); return; }
  if (targetFloor < 1 || targetFloor > 3) {
    enviarMensaje("Target inv√°lido en primaria -> volver a ESPERA");
    estado = ESTADO_ESPERA_PISOS;
    return;
  }
  if (targetFloor > currentFloor) {
    estado = ESTADO_MOVIMIENTO_SUBIENDO;
    return;
  } else if (targetFloor < currentFloor) {
    estado = ESTADO_MOVIMIENTO_BAJANDO;
    return;
  } else {
    enviarMensaje("Ya en piso objetivo -> APERTURA_PUERTAS");
    estado = ESTADO_APERTURA_PUERTAS;
    return;
  }
}

void state_movimiento_subiendo() {
  char buffer[60];
  snprintf(buffer, sizeof(buffer), "[ESTADO_MOVIMIENTO_SUBIENDO] Destino P%d", targetFloor);
  enviarMensaje(buffer);
  
  registerExternalCallsIfAny();
  if (emergencySignal()) { enterEmergency("Emergencia antes de iniciar subida"); return; }
  activateUpSafe();

  while (!sensorAtFloor(targetFloor)) {
    int internal = readInternalCall();
    if (internal > 0) {
      snprintf(buffer, sizeof(buffer), "Orden INTERNA detectada durante subida -> nuevo destino P%d", internal);
      enviarMensaje(buffer);
      targetFloor = internal;
      if (targetFloor < currentFloor) {
        enviarMensaje("Cambio de direcci√≥n requerido durante subida: deteniendo y cambiando a bajar");
        stopMotion();
        delay(10);
        if (!anyDoorClosed()) { enterEmergency("Puertas abiertas al intentar cambiar de direccion"); return; }
        if (digitalRead(FC_LIM_INF) == HIGH) { enterEmergency("Limite inferior activo al cambiar direccion"); return; }
        activateDownSafe();
      }
    }
    registerExternalCallsIfAny();
    if (emergencySignal()) { stopMotion(); enterEmergency("Emergencia detectada durante subida"); return; }
    if (digitalRead(FC_LIM_SUP) == HIGH) { stopMotion(); enterEmergency("Limite superior activado durante subida"); return; }
    delay(5);
  }

  stopMotion();
  currentFloor = targetFloor;
  snprintf(buffer, sizeof(buffer), "Llegado a Piso %d (subida). Transicion a APERTURA_PUERTAS", currentFloor);
  enviarMensaje(buffer);
  estado = ESTADO_APERTURA_PUERTAS;
  lastActivity = millis();
}

void state_movimiento_bajando() {
  char buffer[60];
  snprintf(buffer, sizeof(buffer), "[ESTADO_MOVIMIENTO_BAJANDO] Destino P%d", targetFloor);
  enviarMensaje(buffer);
  
  registerExternalCallsIfAny();
  if (emergencySignal()) { enterEmergency("Emergencia antes de iniciar bajada"); return; }
  activateDownSafe();

  while (!sensorAtFloor(targetFloor)) {
    int internal = readInternalCall();
    if (internal > 0) {
      snprintf(buffer, sizeof(buffer), "Orden INTERNA detectada durante bajada -> nuevo destino P%d", internal);
      enviarMensaje(buffer);
      targetFloor = internal;
      if (targetFloor > currentFloor) {
        enviarMensaje("Cambio de direccion requerido durante bajada: deteniendo y cambiando a subir");
        stopMotion();
        delay(10);
        if (!anyDoorClosed()) { enterEmergency("Puertas abiertas al intentar cambiar direccion"); return; }
        if (digitalRead(FC_LIM_SUP) == HIGH) { enterEmergency("Limite sup activo"); return; }
        activateUpSafe();
      }
    }
    registerExternalCallsIfAny();
    if (emergencySignal()) { stopMotion(); enterEmergency("Emergencia detectada durante bajada"); return; }
    if (digitalRead(FC_LIM_INF) == HIGH) { stopMotion(); enterEmergency("Limite inferior activado durante bajada"); return; }
    delay(5);
  }

  stopMotion();
  currentFloor = targetFloor;
  snprintf(buffer, sizeof(buffer), "Llegado a Piso %d (bajada). Transicion a APERTURA_PUERTAS", currentFloor);
  enviarMensaje(buffer);
  estado = ESTADO_APERTURA_PUERTAS;
  lastActivity = millis();
}

void state_apertura_puertas() {
  char buffer[60];
  snprintf(buffer, sizeof(buffer), "[ESTADO_APERTURA_PUERTAS] Piso %d", currentFloor);
  enviarMensaje(buffer);
  
  if (emergencySignal()) { enterEmergency("Emergencia justo antes de apertura"); return; }
  performDoorSequence();

  if (emergencySignal()) { enterEmergency("Emergencia tras apertura"); return; }

  estado = ESTADO_VENTANA_INTERNA;
}

void state_ventana_interna() {
  enviarMensaje("[ESTADO_VENTANA_INTERNA] Esperando orden interna 10s");
  unsigned long t0 = millis();
  while (millis() - t0 < DOOR_WAIT_MS) {
    registerExternalCallsIfAny();
    if (emergencySignal()) { enterEmergency("Emergencia durante ventana interna"); return; }
    int internal = readInternalCall();
    if (internal > 0) {
      char buffer[70];
      snprintf(buffer, sizeof(buffer), "Orden INTERNA recibida en ventana interna -> P%d (prioridad)", internal);
      enviarMensaje(buffer);
      targetFloor = internal;
      estado = ESTADO_ATENDIENDO_LLAMADA_PRIMARIA;
      return;
    }
    delay(5);
  }

  if (callQueue[0] > 0) {
    targetFloor = popExternalCall();
    char buffer[60];
    snprintf(buffer, sizeof(buffer), "No hubo orden interna. Atendiendo llamada secundaria: P%d", targetFloor);
    enviarMensaje(buffer);
    estado = ESTADO_ATENDIENDO_LLAMADA_SECUNDARIA;
    return;
  } else {
    enviarMensaje("No hay segunda llamada. Esperando 10s adicionales antes de retornar si no llega nada.");
    unsigned long t1 = millis();
    while (millis() - t1
