<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monitor Ascensor ESP32 - Tiempo Real</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 25px;
    }

    .left-panel {
      display: flex;
      flex-direction: column;
      gap: 25px;
    }

    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 25px;
    }

    header {
      background: rgba(255, 255, 255, 0.95);
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      text-align: center;
      grid-column: 1 / -1;
    }

    h1 {
      color: #333;
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .status-badge {
      display: inline-block;
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
      margin-top: 10px;
    }

    .status-connected {
      background: #10b981;
      color: white;
    }

    .status-disconnected {
      background: #ef4444;
      color: white;
    }

    .status-loading {
      background: #f59e0b;
      color: white;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .stat-label {
      color: #666;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .stat-value {
      color: #333;
      font-size: 1.8rem;
      font-weight: bold;
    }

    .logs-container {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      height: 600px;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 2px solid #e5e7eb;
    }

    .logs-title {
      font-size: 1.3rem;
      color: #333;
      font-weight: 600;
    }

    .clear-btn {
      background: #ef4444;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .clear-btn:hover {
      background: #dc2626;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    #logs {
      background: #1e293b;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 10px;
      flex: 1;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #logs::-webkit-scrollbar {
      width: 10px;
    }

    #logs::-webkit-scrollbar-track {
      background: #0f172a;
      border-radius: 10px;
    }

    #logs::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 10px;
    }

    #logs::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    .log-line {
      padding: 4px 0;
      border-left: 3px solid transparent;
      padding-left: 10px;
      margin: 2px 0;
    }

    .log-info { color: #60a5fa; border-left-color: #60a5fa; }
    .log-success { color: #34d399; border-left-color: #34d399; }
    .log-warning { color: #fbbf24; border-left-color: #fbbf24; }
    .log-error { color: #f87171; border-left-color: #f87171; }
    .log-emergency { color: #dc2626; border-left-color: #dc2626; font-weight: bold; }
    .log-system { color: #a78bfa; border-left-color: #a78bfa; }

    .timestamp {
      color: #94a3b8;
      font-weight: normal;
    }

    /* Contenedor 3D */
    .elevator-3d-container {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      height: 600px;
      position: relative;
    }

    .elevator-3d-title {
      font-size: 1.3rem;
      color: #333;
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
    }

    #canvas-3d {
      width: 100%;
      height: calc(100% - 50px);
      border-radius: 10px;
      background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .loading {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr;
      }

      .stats-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.5rem;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      #logs {
        font-size: 11px;
      }

      .elevator-3d-container,
      .logs-container {
        height: 400px;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
</head>
<body>
  <div class="container">
    <header style="grid-column: 1 / -1;">
      <h1>üè¢ Monitor Ascensor ESP32</h1>
      <div id="status-badge" class="status-badge status-loading loading">
        Conectando a Firebase...
      </div>
    </header>

    <div class="left-panel">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">Total Mensajes</div>
          <div class="stat-value" id="total-messages">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Piso Actual</div>
          <div class="stat-value" id="current-floor">-</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Estado</div>
          <div class="stat-value" id="system-status">Iniciando</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">√öltima Actualizaci√≥n</div>
          <div class="stat-value" id="last-update" style="font-size: 1.2rem;">-</div>
        </div>
      </div>

      <div class="logs-container">
        <div class="logs-header">
          <div class="logs-title">üìã Registro de Eventos</div>
          <button class="clear-btn" onclick="clearLogs()">üóëÔ∏è Limpiar</button>
        </div>
        <div id="logs">Esperando datos del ESP32...</div>
      </div>
    </div>

    <div class="right-panel">
      <div class="elevator-3d-container">
        <div class="elevator-3d-title">üèóÔ∏è Vista 3D del Ascensor</div>
        <canvas id="canvas-3d"></canvas>
      </div>
    </div>
  </div>

<script>
  // ==================== CONFIGURACI√ìN FIREBASE ====================
  const firebaseConfig = {
    apiKey: "AIzaSyAU31I1rNQCDLxG-ayjKS61uTo6oUuCmCA",
    authDomain: "monitor-ascensor.firebaseapp.com",
    databaseURL: "https://monitor-ascensor-default-rtdb.firebaseio.com",
    projectId: "monitor-ascensor",
    storageBucket: "monitor-ascensor.appspot.com",
    messagingSenderId: "64032364230",
    appId: "1:64032364230:web:8afb090f6debefeccfa9c7"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const logsDiv = document.getElementById('logs');
  const statusBadge = document.getElementById('status-badge');
  const totalMessages = document.getElementById('total-messages');
  const currentFloor = document.getElementById('current-floor');
  const systemStatus = document.getElementById('system-status');
  const lastUpdate = document.getElementById('last-update');

  let messageCount = 0;

  // ==================== CONFIGURACI√ìN THREE.JS ====================
  const canvas = document.getElementById('canvas-3d');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);

  const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(8, 6, 8);
  camera.lookAt(0, 3, 0);

  const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // Luces
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
  mainLight.position.set(5, 10, 5);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  scene.add(mainLight);

  const fillLight = new THREE.PointLight(0x667eea, 0.5);
  fillLight.position.set(-5, 5, 0);
  scene.add(fillLight);

  // Estructura del ascensor exterior (perfiles met√°licos)
  const buildingGroup = new THREE.Group();

  // Material de perfiles met√°licos (tubo cuadrado)
  const profileMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x2c3e50,
    metalness: 0.9,
    roughness: 0.3
  });

  const floorHeight = 2.5;
  const floorPositions = [0, floorHeight, floorHeight * 2]; // Pisos 1, 2, 3
  const profileSize = 0.1; // Tama√±o del tubo cuadrado

  // Funci√≥n para crear un perfil tubular cuadrado
  function createProfile(length, axis) {
    const geometry = new THREE.BoxGeometry(
      axis === 'x' ? length : profileSize,
      axis === 'y' ? length : profileSize,
      axis === 'z' ? length : profileSize
    );
    const mesh = new THREE.Mesh(geometry, profileMaterial);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
  }

  // Altura total de la estructura
  const totalHeight = floorHeight * 3;

  // Columnas verticales (4 esquinas)
  const columnHeight = totalHeight + 0.5;
  
  // Columna frontal izquierda
  const columnFL = createProfile(columnHeight, 'y');
  columnFL.position.set(-1.2, columnHeight / 2, 1.2);
  buildingGroup.add(columnFL);

  // Columna frontal derecha
  const columnFR = createProfile(columnHeight, 'y');
  columnFR.position.set(1.2, columnHeight / 2, 1.2);
  buildingGroup.add(columnFR);

  // Columna trasera izquierda
  const columnBL = createProfile(columnHeight, 'y');
  columnBL.position.set(-1.2, columnHeight / 2, -1.2);
  buildingGroup.add(columnBL);

  // Columna trasera derecha
  const columnBR = createProfile(columnHeight, 'y');
  columnBR.position.set(1.2, columnHeight / 2, -1.2);
  buildingGroup.add(columnBR);

  // Rieles gu√≠a para el ascensor (centrados)
  const railHeight = totalHeight + 0.3;
  
  const railLeft = createProfile(railHeight, 'y');
  railLeft.position.set(-0.95, railHeight / 2, 1.2);
  buildingGroup.add(railLeft);

  const railRight = createProfile(railHeight, 'y');
  railRight.position.set(0.95, railHeight / 2, 1.2);
  buildingGroup.add(railRight);

  // Crear plataformas de cada piso
  const platformMaterial = new THREE.MeshStandardMaterial({
    color: 0x34495e,
    metalness: 0.6,
    roughness: 0.4
  });

  for (let i = 0; i < 3; i++) {
    const y = floorPositions[i];

    // Plataforma del piso
    const platformGeometry = new THREE.BoxGeometry(2.5, 0.08, 2.5);
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    platform.position.set(0, y, 0);
    platform.receiveShadow = true;
    buildingGroup.add(platform);

    // Vigas horizontales del piso (marco)
    // Frontal
    const beamFront = createProfile(2.5, 'x');
    beamFront.position.set(0, y, 1.2);
    buildingGroup.add(beamFront);

    // Trasera
    const beamBack = createProfile(2.5, 'x');
    beamBack.position.set(0, y, -1.2);
    buildingGroup.add(beamBack);

    // Lateral izquierda
    const beamLeft = createProfile(2.5, 'z');
    beamLeft.position.set(-1.2, y, 0);
    buildingGroup.add(beamLeft);

    // Lateral derecha
    const beamRight = createProfile(2.5, 'z');
    beamRight.position.set(1.2, y, 0);
    buildingGroup.add(beamRight);

    // N√∫mero del piso (cartel)
    const canvas2d = document.createElement('canvas');
    canvas2d.width = 256;
    canvas2d.height = 256;
    const ctx = canvas2d.getContext('2d');
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, 256, 256);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 180px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((3 - i).toString(), 128, 128);

    const texture = new THREE.CanvasTexture(canvas2d);
    const numberMaterial = new THREE.MeshBasicMaterial({ map: texture });
    const numberGeometry = new THREE.PlaneGeometry(0.8, 0.8);
    const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
    numberMesh.position.set(-1.4, y + 1.2, 0);
    numberMesh.rotation.y = Math.PI / 2;
    buildingGroup.add(numberMesh);

    // Barandas de seguridad (solo en parte trasera y laterales)
    const railingMaterial = new THREE.MeshStandardMaterial({
      color: 0x7f8c8d,
      metalness: 0.8,
      roughness: 0.4
    });

    // Barandilla trasera
    const railingBack = new THREE.Mesh(
      new THREE.BoxGeometry(2.4, 0.05, 0.05),
      railingMaterial
    );
    railingBack.position.set(0, y + 1, -1.2);
    buildingGroup.add(railingBack);

    // Barandilla lateral izquierda
    const railingLeft = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.05, 2.4),
      railingMaterial
    );
    railingLeft.position.set(-1.2, y + 1, 0);
    buildingGroup.add(railingLeft);

    // Barandilla lateral derecha
    const railingRight = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.05, 2.4),
      railingMaterial
    );
    railingRight.position.set(1.2, y + 1, 0);
    buildingGroup.add(railingRight);
  }

  // Viga superior (techo de estructura)
  const topBeamFront = createProfile(2.5, 'x');
  topBeamFront.position.set(0, totalHeight, 1.2);
  buildingGroup.add(topBeamFront);

  const topBeamBack = createProfile(2.5, 'x');
  topBeamBack.position.set(0, totalHeight, -1.2);
  buildingGroup.add(topBeamBack);

  const topBeamLeft = createProfile(2.5, 'z');
  topBeamLeft.position.set(-1.2, totalHeight, 0);
  buildingGroup.add(topBeamLeft);

  const topBeamRight = createProfile(2.5, 'z');
  topBeamRight.position.set(1.2, totalHeight, 0);
  buildingGroup.add(topBeamRight);

  // Base de la estructura (suelo)
  const baseGeometry = new THREE.BoxGeometry(4, 0.2, 4);
  const baseMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x34495e,
    metalness: 0.4,
    roughness: 0.8
  });
  const base = new THREE.Mesh(baseGeometry, baseMaterial);
  base.position.y = -0.1;
  base.receiveShadow = true;
  buildingGroup.add(base);

  scene.add(buildingGroup);

  // Cabina del ascensor (estructura con perfiles)
  const cabinGroup = new THREE.Group();
  
  // Marco de la cabina (perfiles tubulares cuadrados)
  const cabinProfileMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x3498db,
    metalness: 0.9,
    roughness: 0.2
  });

  const cabinWidth = 1.6;
  const cabinHeight = 2.2;
  const cabinDepth = 1.6;

  // Perfiles verticales de las esquinas
  const verticalProfile = (x, z) => {
    const profile = createProfile(cabinHeight, 'y');
    profile.position.set(x, 0, z);
    profile.material = cabinProfileMaterial;
    return profile;
  };

  cabinGroup.add(verticalProfile(-cabinWidth/2, -cabinDepth/2)); // Trasera izq
  cabinGroup.add(verticalProfile(cabinWidth/2, -cabinDepth/2));  // Trasera der
  cabinGroup.add(verticalProfile(-cabinWidth/2, cabinDepth/2));  // Frontal izq
  cabinGroup.add(verticalProfile(cabinWidth/2, cabinDepth/2));   // Frontal der

  // Perfiles horizontales superiores
  const topProfileFront = createProfile(cabinWidth, 'x');
  topProfileFront.material = cabinProfileMaterial;
  topProfileFront.position.set(0, cabinHeight/2, cabinDepth/2);
  cabinGroup.add(topProfileFront);

  const topProfileBack = createProfile(cabinWidth, 'x');
  topProfileBack.material = cabinProfileMaterial;
  topProfileBack.position.set(0, cabinHeight/2, -cabinDepth/2);
  cabinGroup.add(topProfileBack);

  const topProfileLeft = createProfile(cabinDepth, 'z');
  topProfileLeft.material = cabinProfileMaterial;
  topProfileLeft.position.set(-cabinWidth/2, cabinHeight/2, 0);
  cabinGroup.add(topProfileLeft);

  const topProfileRight = createProfile(cabinDepth, 'z');
  topProfileRight.material = cabinProfileMaterial;
  topProfileRight.position.set(cabinWidth/2, cabinHeight/2, 0);
  cabinGroup.add(topProfileRight);

  // Perfiles horizontales inferiores
  const bottomProfileFront = createProfile(cabinWidth, 'x');
  bottomProfileFront.material = cabinProfileMaterial;
  bottomProfileFront.position.set(0, -cabinHeight/2, cabinDepth/2);
  cabinGroup.add(bottomProfileFront);

  const bottomProfileBack = createProfile(cabinWidth, 'x');
  bottomProfileBack.material = cabinProfileMaterial;
  bottomProfileBack.position.set(0, -cabinHeight/2, -cabinDepth/2);
  cabinGroup.add(bottomProfileBack);

  const bottomProfileLeft = createProfile(cabinDepth, 'z');
  bottomProfileLeft.material = cabinProfileMaterial;
  bottomProfileLeft.position.set(-cabinWidth/2, -cabinHeight/2, 0);
  cabinGroup.add(bottomProfileLeft);

  const bottomProfileRight = createProfile(cabinDepth, 'z');
  bottomProfileRight.material = cabinProfileMaterial;
  bottomProfileRight.position.set(cabinWidth/2, -cabinHeight/2, 0);
  cabinGroup.add(bottomProfileRight);

  // Piso de la cabina (rejilla met√°lica)
  const floorGeometry = new THREE.BoxGeometry(cabinWidth, 0.08, cabinDepth);
  const floorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x7f8c8d,
    metalness: 0.7,
    roughness: 0.5
  });
  const cabinFloor = new THREE.Mesh(floorGeometry, floorMaterial);
  cabinFloor.position.y = -cabinHeight/2;
  cabinFloor.castShadow = true;
  cabinFloor.receiveShadow = true;
  cabinGroup.add(cabinFloor);

  // Techo de la cabina
  const roofGeometry = new THREE.BoxGeometry(cabinWidth + 0.2, 0.1, cabinDepth + 0.2);
  const roofMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x2c3e50,
    metalness: 0.8,
    roughness: 0.3
  });
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.position.y = cabinHeight/2 + 0.05;
  roof.castShadow = true;
  cabinGroup.add(roof);

  // Paredes trasera y laterales (malla met√°lica semi-transparente)
  const wallMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x5dade2,
    metalness: 0.6,
    roughness: 0.4,
    transparent: true,
    opacity: 0.3
  });

  // Pared trasera
  const backWallGeometry = new THREE.BoxGeometry(cabinWidth - 0.2, cabinHeight - 0.2, 0.02);
  const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
  backWall.position.set(0, 0, -cabinDepth/2 + 0.05);
  cabinGroup.add(backWall);

  // Pared lateral izquierda
  const leftWallGeometry = new THREE.BoxGeometry(0.02, cabinHeight - 0.2, cabinDepth - 0.2);
  const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
  leftWall.position.set(-cabinWidth/2 + 0.05, 0, 0);
  cabinGroup.add(leftWall);

  // Pared lateral derecha
  const rightWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
  rightWall.position.set(cabinWidth/2 - 0.05, 0, 0);
  cabinGroup.add(rightWall);

  // Luz interior de la cabina
  const cabinLight = new THREE.PointLight(0xffffff, 0.8, 4);
  cabinLight.position.set(0, cabinHeight/2 - 0.2, 0);
  cabinGroup.add(cabinLight);

  // PUERTAS CORREDIZAS (frente de la cabina)
  const doorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x34495e,
    metalness: 0.85,
    roughness: 0.2
  });

  const doorWidth = (cabinWidth - 0.15) / 2; // Dos puertas que se dividen
  const doorHeight = cabinHeight - 0.3;
  const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.05);
  
  // Puerta izquierda
  const doorLeft = new THREE.Mesh(doorGeometry, doorMaterial);
  doorLeft.position.set(-doorWidth/2 - 0.025, 0, cabinDepth/2 + 0.025);
  doorLeft.castShadow = true;
  cabinGroup.add(doorLeft);

  // Puerta derecha
  const doorRight = new THREE.Mesh(doorGeometry, doorMaterial);
  doorRight.position.set(doorWidth/2 + 0.025, 0, cabinDepth/2 + 0.025);
  doorRight.castShadow = true;
  cabinGroup.add(doorRight);

  // Marco de las puertas
  const doorFrameMaterial = new THREE.MeshStandardMaterial({
    color: 0x2c3e50,
    metalness: 0.9,
    roughness: 0.3
  });

  // Marco vertical izquierdo
  const frameLeft = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, cabinHeight - 0.15, 0.08),
    doorFrameMaterial
  );
  frameLeft.position.set(-cabinWidth/2 + 0.1, 0, cabinDepth/2 + 0.05);
  cabinGroup.add(frameLeft);

  // Marco vertical derecho
  const frameRight = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, cabinHeight - 0.15, 0.08),
    doorFrameMaterial
  );
  frameRight.position.set(cabinWidth/2 - 0.1, 0, cabinDepth/2 + 0.05);
  cabinGroup.add(frameRight);

  // Marco horizontal superior
  const frameTop = new THREE.Mesh(
    new THREE.BoxGeometry(cabinWidth - 0.2, 0.08, 0.08),
    doorFrameMaterial
  );
  frameTop.position.set(0, cabinHeight/2 - 0.15, cabinDepth/2 + 0.05);
  cabinGroup.add(frameTop);

  cabinGroup.position.y = 1.1; // Posici√≥n inicial en piso 1
  scene.add(cabinGroup);

  // Variables de control del ascensor
  let targetFloor = 1;
  let currentFloorNum = 1;
  let isMoving = false;
  let doorsOpen = false;
  let doorAnimationProgress = 0;
  const doorOpenDistance = 0.65; // Distancia que se abren las puertas

  // Funci√≥n para mover el ascensor a un piso
  function moveElevatorToFloor(floor) {
    if (floor >= 1 && floor <= 3) {
      targetFloor = floor;
      isMoving = true;
    }
  }

  // Funci√≥n para abrir puertas
  function openDoors() {
    doorsOpen = true;
  }

  // Funci√≥n para cerrar puertas
  function closeDoors() {
    doorsOpen = false;
  }

  // Animaci√≥n
  function animate() {
    requestAnimationFrame(animate);

    // Animar movimiento del ascensor
    if (isMoving) {
      const targetY = floorPositions[targetFloor - 1] + 1.1; // Ajuste de altura
      const currentY = cabinGroup.position.y;
      const diff = targetY - currentY;

      if (Math.abs(diff) > 0.01) {
        cabinGroup.position.y += diff * 0.04; // Movimiento suave y realista
      } else {
        cabinGroup.position.y = targetY;
        isMoving = false;
        currentFloorNum = targetFloor;
      }
    }

    // Animar puertas corredizas (horizontal)
    if (doorsOpen && doorAnimationProgress < 1) {
      doorAnimationProgress += 0.025; // Velocidad de apertura
      if (doorAnimationProgress > 1) doorAnimationProgress = 1;
    } else if (!doorsOpen && doorAnimationProgress > 0) {
      doorAnimationProgress -= 0.025; // Velocidad de cierre
      if (doorAnimationProgress < 0) doorAnimationProgress = 0;
    }

    // Aplicar animaci√≥n a las puertas (se deslizan hacia los lados)
    const doorOffset = doorOpenDistance * doorAnimationProgress;
    doorLeft.position.x = -doorWidth/2 - 0.025 - doorOffset;
    doorRight.position.x = doorWidth/2 + 0.025 + doorOffset;

    // Rotaci√≥n suave de la c√°mara alrededor del ascensor
    const time = Date.now() * 0.0002;
    camera.position.x = Math.cos(time) * 9;
    camera.position.z = Math.sin(time) * 9;
    camera.position.y = 5;
    camera.lookAt(0, 3.5, 0);

    renderer.render(scene, camera);
  }

  animate();

  // Ajustar tama√±o en ventana
  window.addEventListener('resize', () => {
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });

  // ==================== INTEGRACI√ìN CON FIREBASE ====================
  
  function classifyMessage(msg) {
    const text = msg.toLowerCase();
    
    // EMERGENCIAS (rojo brillante)
    if (text.includes('emergencia') || text.includes('üö®')) {
      return 'log-emergency';
    }
    
    // ERRORES Y ADVERTENCIAS (rojo/amarillo)
    if (text.includes('error') || text.includes('‚ùå') || 
        text.includes('advertencia') || text.includes('‚ö†') ||
        text.includes('l√≠mite')) {
      return 'log-error';
    }
    
    // OPERACIONES EXITOSAS (verde)
    if (text.includes('completad') || text.includes('‚úÖ') || 
        text.includes('‚úî') || text.includes('alcanzado') ||
        text.includes('iniciado') || text.includes('ok')) {
      return 'log-success';
    }
    
    // MOVIMIENTO DEL MOTOR (amarillo destacado)
    if (text.includes('motor subiendo') || text.includes('motor bajando') ||
        text.includes('üîº') || text.includes('üîΩ')) {
      return 'log-warning';
    }
    
    // LLAMADAS Y COLA (amarillo)
    if (text.includes('llamada') || text.includes('üìû') || 
        text.includes('cola') || text.includes('üìã')) {
      return 'log-warning';
    }
    
    // PUERTAS (azul)
    if (text.includes('puerta') || text.includes('üö™')) {
      return 'log-info';
    }
    
    // SISTEMA Y CONFIGURACI√ìN (morado)
    if (text.includes('iniciando') || text.includes('sistema') ||
        text.includes('secuencia') || text.includes('conectado') ||
        text.includes('wifi') || text.includes('ip:')) {
      return 'log-system';
    }
    
    return 'log-info';
  }

  function updateStats(msg) {
    const text = msg.toLowerCase();
    
    // ==================== SINCRONIZACI√ìN PERFECTA CON ESP32 ====================
    
    // DETECTAR MENSAJES CLAVE DEL MOTOR
    if (text.includes('üîº motor subiendo')) {
      systemStatus.textContent = 'Subiendo';
      systemStatus.style.color = '#10b981';
      isMoving = true; // Activar movimiento en 3D
    } else if (text.includes('üîΩ motor bajando')) {
      systemStatus.textContent = 'Bajando';
      systemStatus.style.color = '#f59e0b';
      isMoving = true; // Activar movimiento en 3D
    }
    
    // DETECTAR PISO ALCANZADO (detener movimiento y actualizar)
    if (text.includes('alcanzado')) {
      const match = text.match(/piso (\d)/);
      if (match) {
        const floor = parseInt(match[1]);
        currentFloor.textContent = floor;
        targetFloor = floor;
        moveElevatorToFloor(floor);
        
        // Estado despu√©s de llegar
        systemStatus.textContent = 'En Piso ' + floor;
        systemStatus.style.color = '#3498db';
      }
    }
    
    // DETECTAR PISO ACTUAL AL INICIO
    if (text.includes('detectado: piso')) {
      const match = text.match(/piso (\d)/);
      if (match) {
        const floor = parseInt(match[1]);
        currentFloor.textContent = floor;
        targetFloor = floor;
        // Posicionar inmediatamente sin animaci√≥n
        cabinGroup.position.y = floorPositions[floor - 1] + 1.1;
        currentFloorNum = floor;
        isMoving = false;
      }
    }

    // DETECTAR SUBIENDO/BAJANDO (indicadores adicionales)
    if (text.includes('‚¨Ü') || text.includes('subiendo')) {
      systemStatus.textContent = 'Subiendo';
      systemStatus.style.color = '#10b981';
    } else if (text.includes('‚¨á') || text.includes('bajando')) {
      systemStatus.textContent = 'Bajando';
      systemStatus.style.color = '#f59e0b';
    }

    // DETECTAR APERTURA DE PUERTAS
    if (text.includes('üö™ puertas abiertas')) {
      openDoors();
      systemStatus.textContent = 'Puertas Abiertas';
      systemStatus.style.color = '#e67e22';
    }
    
    // DETECTAR CIERRE DE PUERTAS
    if (text.includes('üö™ cerrando puertas')) {
      closeDoors();
    }
    
    // DETECTAR ESTADOS DEL SISTEMA
    if (text.includes('‚úÖ') && text.includes('iniciado')) {
      systemStatus.textContent = 'Sistema Activo';
      systemStatus.style.color = '#10b981';
    } else if (text.includes('esperando llamadas')) {
      systemStatus.textContent = 'En Espera';
      systemStatus.style.color = '#10b981';
    } else if (text.includes('üö®') && text.includes('emergencia')) {
      systemStatus.textContent = '‚ö†Ô∏è EMERGENCIA';
      systemStatus.style.color = '#ef4444';
      isMoving = false;
      closeDoors();
    } else if (text.includes('procesando llamada')) {
      systemStatus.textContent = 'Procesando';
      systemStatus.style.color = '#f59e0b';
    }
    
    // DETECTAR LLAMADAS EN COLA
    if (text.includes('üìû llamada agregada')) {
      const match = text.match(/piso (\d)/);
      if (match) {
        // Indicador visual de llamada recibida
        console.log('Llamada detectada para piso ' + match[1]);
      }
    }
  }

  function addLog(timestamp, msg) {
    const date = new Date(Number(timestamp));
    const timeStr = date.toLocaleTimeString('es-ES');
    const logClass = classifyMessage(msg);
    
    const logLine = document.createElement('div');
    logLine.className = `log-line ${logClass}`;
    logLine.innerHTML = `<span class="timestamp">[${timeStr}]</span> ${msg}`;
    
    logsDiv.appendChild(logLine);
    logsDiv.scrollTop = logsDiv.scrollHeight;
    
    messageCount++;
    totalMessages.textContent = messageCount;
    lastUpdate.textContent = timeStr;
    
    updateStats(msg);
  }

  // Verificar conexi√≥n
  const connectedRef = db.ref(".info/connected");
  connectedRef.on("value", (snap) => {
    if (snap.val() === true) {
      statusBadge.textContent = '‚úÖ Conectado a Firebase';
      statusBadge.className = 'status-badge status-connected';
    } else {
      statusBadge.textContent = '‚ùå Desconectado';
      statusBadge.className = 'status-badge status-disconnected';
    }
  });

  // Escuchar mensajes nuevos
  const messagesRef = db.ref('messages');
  messagesRef.on('child_added', (snapshot) => {
    const value = snapshot.val();
    const timestamp = value.timestamp || Date.now();
    const msgText = value.mensaje || JSON.stringify(value);
    addLog(timestamp, msgText);
  });

  messagesRef.once('value', (snap) => {
    if (!snap.exists()) {
      logsDiv.innerHTML = '<div class="log-line log-info">‚è≥ Esperando mensajes del ESP32...</div>';
    }
  });

  function clearLogs() {
    if (confirm('¬øDeseas limpiar todos los logs?')) {
      logsDiv.innerHTML = '<div class="log-line log-info">üìã Logs limpiados</div>';
      messageCount = 0;
      totalMessages.textContent = '0';
    }
  }
</script>
</body>
</html>
